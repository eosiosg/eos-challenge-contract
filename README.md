# EOSEVM - Simulate EVM in EOS Contract

## Features

- Simulate an EVM Interpreter in EOSIO smart contract and execute EVM transactions as faithfully to the Ethereum Yellow Paper as possible
- NO CHANGES to the EOSIO software
- Follow EVMC standard.
- Fully support all EVMC_REVISIONs
- Support dry-run transaction execution. //TODO add example and document
- Detailed Functions
    - EOS user can create a eth address associated with his/her EOS account, and use EOS account private key to execute challenge transactions.
    - ETH user can create an account through BFSP by provide an eth address. Afterwards the ETH user can call EVM contracts (deployed in challenge contract) exactly the same way as in ETH, except that a BFSP is needed to forward transactions.
    - The challenge contract can link customisable external token contract and symbol.
    - Associated accounts can transfer/withdraw linked token between external token contract and challenge contract.
    - All accounts can use EVM transfer transaction to send linked token inside the challenge contract.
    - All accounts can deploy and execute EVM bytecode, and contract address is created following ETH rules.
    - GAS fee is calculated but not billed.
    - Persist smart contract data with native EOSIO multi-index. Revert **dirty state** if vm execution failed.
    - Detailed challenge requirements are discussed in "eos-challenge-contract project", such as GAS fee, chain-id, nonce and so on.

## EOSEVM Challenge Solution and Implementation

### Requirement 1: 
```
The Application MUST persist an “Account Table” consisting of

A unique 160bit account ID
A nonce (sequence number)
An EOSIO token balance (aka SYS)
[optional] A unique associated EOSIO account
```
### Solution 1:
- 160bit ETH address ID generated by the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the EOSIO account name and the arbitrary input string
- Nonce represented by **uint256_t** is consistent with go-ethereum
- Balance represented by uint256\_t alise type of eosio::checksum256. Balance is recorded as uint256_t instead of asset because native Wei has 18 digits after the decimal point and can not represent with asset in some cases
- Two types of ETH address
	- native ETH address, the user must have ETH private key. field leaves blank
	- EOS associate fake ETH address, the user do not have ETH private key. The field will be set EOS account **compulsory**.

### Implementation 1:
```c
struct [[eosio::table("eos_evm")]] st_account {
	uint64_t           id;
	eth_addr_160       eth_address;
	uint256_t          nonce;
	uint256_t          balance;
	name               eosio_account;
};
```

### Requirement 2: 
```
The Application MUST persist an “Account State Table” per account, if it would not be empty, consisting of

 - How to Build -
   - cd to 'build' directory
   - run the command 'cmake ..'
   - run the command 'make'

 - After build -
   - The built smart contract is under the 'eos_evm' directory in the 'build' directory
   - You can then do a 'set contract' action with 'cleos' and point in to the './build/eos_evm' directory

 - Additions to CMake should be done to the CMakeLists.txt in the './src' directory and not in the top level CMakeLists.txt
 
## Add evmone as static library


## Add ethash and keccak lib to smart contract
#### 1. clone ethash
```
git clone https://github.com/chfast/ethash
```
#### 2. add lib to CMakeList.txt
```
add_subdirectory(ethash)
link_libraries(ethash)
link_libraries(keccak)
```

## Add intx to smart contract
#### Add intx source code to include folder directy to build with smart contract
