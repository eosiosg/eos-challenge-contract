# EOSEVM - Running Solidity Smart Contract on EOS

## Description
Some of features of EOSEVM include: 

1. Running solidity smart contract on EOSIO
2. Simulate an EVM Interpreter in EOSIO smart contract and execute EVM transactions as faithfully to the Ethereum Yellow Paper as possible
3. Connect to EVMC, replace the EVMs any time and without efforts, same for evmjit and ewasm
4. Create account in two ways. One is ETH address associate EOS account uniquely, the other is native ETH address which user must own private key
5. Verify signature in two ways. Similar to account creation, one is EOS associate account **reqiure_auth**, the other is native ETH address recover.
6. Persist Solidity smart contract data with native EOSIO multi-index
7. Gas free. Maintain whole gas system to calculate gas, and force set gas price = 0. 
8. Simulate transaction execution in API node.


## EOSEVM smart contract

### 1. Tables

#### a. Account table

 * ID : primary key
 * A unique 160bit account ID : native ETH address or **fake** ETH address associate EOSIO account generated by RLP encoding with EOS account and an arbitrary length string
 * A nonce (sequence number) : nonce value represent by **uint256_t** and increases by one in every transaction of this sender. Same with ETH nonce type.
 * An EOSIO token balance (aka SYS): linked token as native **'ether token'** which can be transferred in ETH transactions and used to gas payment (even though gas price is forced set to 0)
 * [optional] A unique associated EOSIO account: if ETH address generated by RLP encoding with EOS account and an arbitrary length string. The field will be set EOS account **compulsory**. if native ETH address. The field will be blank.

#### b. Account State Table
Account State Table will record solidity smart contract state as a **key-value** database

 * ID: primary key
 * A unique 256bit key
 * A 256bit value

#### c. Account Code Table
 * ETH address : ETH address shown in account table
 * EVM bytecode associated with account

#### d. Linked Token contract Table
Linked token contract table will record an extended_symbol linked with EOS token smart contract as native **'ether token'**

 * ID: primary key
 * contract: extended\_symbol

 
### 2. Actions

a. create

- Declaration: 
```c
[[eosio::action]] void create(const name &eos_account, const binary_extension<std::string> &eth_address);
```

- Inputs
  - eos_account: A binary Ethereum transaction encoded as it appears in a serialized Ethereum block
  - An arbitrary-length string

- Result
  - Balance = 0
  - Nonce = 1
  - Account identifier = the rightmost 160 bits of the Keccak hash of the RLP encoding of the structure containing only the EOSIO account name and the arbitrary input string

- Explanation
	 - Two types of **ETH address**. One is native ETH address which user must have **private key**, the other is EOS associate fake ETH address. That means when a user wishes to send a transaction, the user can choose to use ETH private key or EOS private key to sign.
	 - If native ETH address creation, the second param must be native ETH address
	 - If EOS associates ETH address, the second param can be arbitrary length string.

- Implementation
	 - If the second param has **160 bits**, then set ETH address directly with this param value in account table
	 - If the second param arbitrary length string, then generate a fake ETH address which user does not have the private key with above **RLP algorithm**
	 - Balance is recorded as **uint256_t** instead of **asset** because **native Wei** has **18 digits after the decimal point** and can not represent with asset in some cases
	 - Nonce is also recorded as **uint256_t** match the specification in Ethereum Yellow Paper


b. raw

- Declaration: 
```c
[[eosio::action]] void raw(const hex_code &trx_code, const binary_extension<eth_addr_160> &sender);
```

- Inputs
   - trx_code: A binary Ethereum transaction encoded as it appears in a serialized Ethereum block
   - sender: [optional] A 160bit account identifier “Sender”, 

- Result
   - Appropriate Updates to Account, Account State, and Account Code Tables reflecting the application of the transaction
   - Log output (via EOSIO print intrinsics)
- IF the “R” and “S” values of the transaction are NOT 0
	- A transaction containing this action must fail if the signature (V, R, S) within the input does not recover to a valid and known 160bit account identifier in the Accounts Table

- IF the “R” and “S” values of the transaction are 0
	- A transaction containing this action must fail if “Sender” input parameter is not present or does not refer to a valid and known 160bit account identifier in the Accounts Table
If the associated entry in the Accounts Table has no Associated EOSIO Account
OR if the transaction has not been authorized by the Associated EOSIO Account

- Explanation
	- Two types **signature verification** in raw action. If trx\_code is native ETH address sender signed transaction, sender param leave blank. Raw action will use recover ETH address from sender signature. If trx\_code has no signature, sender param must be EOS signer associate fake ETH address shown in account table mentioned above. That means a trx\_code **must** have one kind of signature to be verified.

- Implementation
	- RLP decode trx\_code with field **nonce, gasPrice, gasLimit, to, value, and signature related v,r,s**
	- Two types of **signature verification**, differentiate by if trx\_code has filed **v, r, s**. if exist, recover native ETH address. if not, **require\_auth** with **second param sender** associated EOS account
	- Two types of **action types** in raw action. There are two types of action in ETH transaction shown in ETH yellow paper differentiate by trx\_code **to** field. One is **contract creation**, the other is **message call**, If contract creation, evm execution result data is **evm code body**. If message call, evm execution result data is as the case may be.
	- Gas calculation. maintain native gas system include **intrinsic gas** and **vm gas** usage. Buy gas and refund gas also avalible.
	- Value transfer. If value != 0, transfer value from **sender** to **to** address.
	- Print vm receipt in **JSON** format and parse easily in JS client
	

c. simulate

- Declaration:
```c
[[eosio::action]] void simulate(const hex_code &trx_code, const binary_extension<eth_addr_160> &sender);
```

- Inputs
   - trx_code: A binary Ethereum transaction encoded as it appears in a serialized Ethereum block
   - sender: [optional] A 160bit account identifier “Sender”, 
- Result
   - simulate VM execution and always be asserted failure
   - Log output (via EOSIO print intrinsics)

- Explanation
	  - Mock API node to send a non-state transaction. Such as check account balance, allowance in ERC20. 

- Implementation
	  - execute same logic with raw action
	  - always assertion failure
	  - JS client can get transaction **JSON receipt** in **assertion failure pending output console**
 
 
d. ontransfer

- Declaration: 
```c
[[eosio::on_notify("*::transfer")]]
void ontransfer(const name &from, const name &to, const asset &quantity, const std::string memo);
```
		
- Input
	- from
	- to
	- quantity
	- memo
- Result
	- Provided that the EOSIO account in the “from” field of the transfer maps to a known and valid Account Table entry through the entry’s unique associated EOSIO account
	- Transferred tokens should be added to the Account Table entry’s balance

- Explanation
	- linked contract transfer notify ontransfer action. And add balance to account table entry.

	
e. withdraw

- Declaration: 
```c
[[eosio::action]] void withdraw(const name &eos_account, const asset &amount);
```

- Input 
	- An EOSIO account
	- A token amount

- Result
	- Deducting the amount from the associated Account Table entry’s balance
	- Sending an inline EOSIO token transfer for the amount to the EOSIO account

- Implementation
	- send an linked contract transfer token inline action with correspond amount

f. linktoken

- Declaration: 
```c
[[eosio::action]] void linktoken(const extended_symbol &contract);
```

- Input
	- linked contract

- Result
	- record **singleton** extended_symbol in token contract

- Explanation
	- record **singleton** extended_symbol in token contract as native **'ether token'** for value transfer and gas fee payment (even though gas price is forced set to 0)

g. log

- Declaration: 
```c
[[eosio::action]] void log(const std::string &status_code, 
				 const std::string &output, 
				 const std::string &from,
				 const std::string &to,
				 const std::string &nonce, 
				 const std::string &gas_price, 
				 const std::string &gas_left, 
				 const std::string &gas_usage, 
				 const std::string &value, 
				 const std::string &data, 
				 const std::string &v, 
				 const std::string &r, 
				 const std::string &s, 
				 const std::string &contract, 
				 const std::string &eth_emit_logs
				);
```
	
- Input
	- log receipt information, include EVM execution result, output, data, signature information, gas price, gas usage, emit_logs.

- Result
	- send and inline transaction recorded on blockchain

- Explanation
	- user can check detail EVM execution receipt on chain


	
	
	
	
	
	
	
	
	

 
